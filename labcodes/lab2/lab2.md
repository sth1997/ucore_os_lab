# Lab2 实验报告

## 实验涉及知识点
内核中的双向链表  
First Fit 内存分配算法  
分页机制与二级页表  

注：由于要求和标准答案对比，我在做lab2时所看到的标准答案是开学第一周、第二周时的答案，据说twd同学之后有给标准答案提交pr，但我并没有去看修改后的答案。所以在本报告中，所进行对比的标准答案可能与最新的标准答案有所不同。

## 练习1 实现 first-fit 连续物理内存分配算法  
我使用的双向链表有如下性质：  
```
    链表的每一项代表一块（包含多页）连续的未分配内存。
    链表中每块未分配内存的首地址递增。
```

### 对default_init_memmap函数的修改  
主要就是维护之前说到的双向链表的性质。  
将分裂出来的块设置属性并放到正确的位置，而不是free_list的最后。我的实现方法是先分裂（例如原来大小为size，分裂成了大小为n和m的两块），将大小为m的块直接插入大小为n的块的后面（大小为n的块原本就在链表里），之后再将大小为n的块删除。  

### 对default_free_pages函数的修改  
同样，主要就是维护之前说道的双向链表的性质。  
通过循环，找到待插入的块应该插入的位置。同时，看链表中的块是否可以和待插入的块合并，若能合并，则将其从链表上删除，并合并入待插入的块。最后，将（合并后的）待插入的块插入。

### 可做的改进  
在default_free_pages函数中，其实可以不用通过循环查找应当插入的位置，可以直接通过待插入的块来计算出下一个块的首地址，并判断其是否空闲，若空闲，则可以在双向链表中找到它的位置。

## 练习2 

注释非常详细，按照注释一步一步写即可。  
我设计的get_pte函数的步骤如下：（设la对应一级页表项为pdep，对应二级页表项为ptep）  
```
    1、若一级页表项pdep存在，则转4。
    2、一级页表项pdep不存在，若不需要create或alloc失败，则返回NULL。
    3、若需要create且alloc成功，则设置page与*pdep，转4。
    4、返回二级页表项ptep的地址。
```

### 2.1 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。  
页目录项（一级页表项）存储了所有二级页表（PT）页的线性基地址+标记信息，页表项（二级页表项）存储了la对应的物理页的基地址+标记信息（lab2中主要用到了最低的三个标记位）。二者基本上可以等同，其低12位的标记信息如下（见mmu.h）：

```C
#define PTE_P           0x001                   // Present 对应物理页面是否存在
#define PTE_W           0x002                   // Writeable 对应物理页面是否可写
#define PTE_U           0x004                   // User 对应物理页面用户态是否可以访问
#define PTE_PWT         0x008                   // Write-Through 对应物理页面在写入时是否写透(即向更低级储存设备写入)
#define PTE_PCD         0x010                   // Cache-Disable 对应物理页面是否能被放入高速缓存
#define PTE_A           0x020                   // Accessed 对应物理页面是否被访问
#define PTE_D           0x040                   // Dirty 对应物理页面是否被写入
#define PTE_PS          0x080                   // Page Size 对应物理页面的页面大小
#define PTE_MBZ         0x180                   // Bits must be zero 必须为零的部分
#define PTE_AVAIL       0xE00                   // Available for software use 用户可自定义的部分
```

替换算法中，被换出的页从pgdir中选出，而pte则存储着被换入页的信息。

### 2.2 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

处理器会将异常的线性地址保存在CR2寄存器中，然后查询IDT找到中断服务程序入口点。由于当前已在内核态，不涉及特权级的变化，处理器还会向当前栈中压入cs、eip和错误码。错误码记录了异常的一些标志，比如是读还是写操作触发了异常，是非法访问还是缺页触发了异常。最后，跳转至中断服务程序。

## 练习3 释放某虚地址所在的页并取消对应二级页表项的映射  
这个函数相对简单，基本思路如下：
```
    首先看二级页表项ptep是否存在，若不存在则直接退出；
    若存在，设其对应的物理页为p，则修改p.ref并释放p；
    清空*ptep的内容；
    将TLB置为无效状态。
```

### 3.1 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？
有对应关系。页表项（PTE）中的每一个有效项对应着一个物理页Page，而每一个页目录项（PDE）对应着一个二级页表（每个二级页表的大小为一页，在练习2中对应分配了一个Page）。

### 3.2 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题。
一种可能的方法是，修改tools/kernel.ld以及入口函数kern_entry，将Lab2的地址映射关系改回Lab1的映射关系，使得虚拟地址与物理地址相等。另一个猜想是，在memlayout.h中修改KERNBASE为0，同时在pmm.c中实现一定的机制，以禁止对保留字段（0x0~0x100000，bootloader和ucore在内存中的物理位置）的访问。