# Lab3 实验报告

## 实验涉及知识点
缺页异常的处理
先进先出替换算法

## 练习1 给未被映射的地址映射上物理页  

do_pgfault()函数是缺页异常的中断处理例程。产生异常的原因有三种：
```
    ①目标页帧不存在：页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销
    ②相应的物理页帧不在内存中：页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上
    ③没有权限：此时页表项P标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面
```  
练习1针对的是第①种原因，即线性地址未与物理地址建立映射。

可以看出，在练习1的代码之前的几个`goto failed;`语句，已经对第③种原因进行了处理。  
故接下来的代码将要处理第①、②种原因。两种情形区分的关键在于：相应页表项（pte）是否存在（不为0），若存在则为第②种原因，否则为第①种原因。

故先用`get_pte()`函数得到页表项`*ptep`，若其为0，则使用`pgdir_alloc_page()`函数为其分配一个新物理页，并建立线性地址到此物理页的映射。

与答案对比，发现我的代码没有对`get_pte()`函数和`pgdir_alloc_page()`函数返回`NULL`的情况进行判断，已改正。

### 1.1 请描述页目录项(Pag	Director Entry)和页表(Page	Table Entry)中组成部分对ucore实现页替换算法的潜在用处
页目录项存储了所有二级页表（PT）的物理基地址+标记信息，页表项存储了la对应的物理页的基地址+标记信息。二者结构基本相同，其低12位的标记信息如下（见mmu.h）：

```
#define PTE_P           0x001                   // Present 对应物理页面是否存在
#define PTE_W           0x002                   // Writeable 对应物理页面是否可写
#define PTE_U           0x004                   // User 对应物理页面用户态是否可以访问
#define PTE_PWT         0x008                   // Write-Through 对应物理页面在写入时是否写透(即向更低级储存设备写入)
#define PTE_PCD         0x010                   // Cache-Disable 对应物理页面是否能被放入高速缓存
#define PTE_A           0x020                   // Accessed 对应物理页面是否被访问
#define PTE_D           0x040                   // Dirty 对应物理页面是否被写入
#define PTE_PS          0x080                   // Page Size 对应物理页面的页面大小
#define PTE_MBZ         0x180                   // Bits must be zero 必须为零的部分
#define PTE_AVAIL       0xE00                   // Available for software use 用户可自定义的部分
```
与页替换算法相关的位有：
```
    PTE_A：可用于某些替换算法的实现（如时钟替换算法）
    PTE_D：若为1，则此页为dirty，在换出时，要修改其对应磁盘上的内容。同时，可用扩展时钟替换算法的实现。
    PTE_P：若为0，页表项变为了swap_entry，用来描述一个被置换出去的物理页，维护该物理页与 swap 磁盘上扇区的映射关系。其他flag位可以用于标记该物理页的更多信息，方便ucore在中断/异常处理时判断要处理的具体情形。
```

### 1.2 如果ucore的缺页服务例程在执行过程中访问内存,出现了页访问异常,请问硬件要做哪些事情?
如果ucore的页错误处理程序执行过程中访问内存，又出现了页错误异常，由于这个异常不可以屏蔽，处理器会将异常的线性地址保存在CR2寄存器中，然后查询IDT找到中断服务程序入口点。由于当前已在内核态，不涉及特权级的变化，处理器还会向当前栈中压入cs、eip和错误码。错误码记录了异常的一些标志，比如是读还是写操作触发了异常，是非法访问还是缺页触发了异常，这对于页替换算法和写时复制的实现都有用。最后，跳转至中断服务程序。这些事情中间还会做权限检查，不通过还会触发保护错误。

## 练习2 补充完成基于FIFO的页面替换算法
练习2对应缺页异常的第②种原因。此时页表项`*ptep`不为0，它代表一个swap_entry。此时该页表项对应的物理页帧page处于被换出的状态，欲处理这个缺页异常，就要将它换入。因此在`do_pgfault()`中，应完成整个换入过程，步骤如下：  
- 首先调用`swap_in()`函数，将page换入。
- 换入后，调用`page_insert()`函数，重写页表项`*ptep`，也即建立虚拟地址addr与物理页帧page间的映射。
- 接下来为页替换算法做一些标记。
```
swap_map_swappable(mm, addr, page, 1); 
page->pra_vaddr = addr; //used when being swaped out
```
- 这里首先调用统一接口`swap_map_swappable()`维护可替换的物理页序列，即将新换入的物理页放到页替换算法的“替换序列”中，方便之后按顺序换出。
- 其次是标记此物理页对应的虚拟地址。

我的实现与答案相同。


对于FIFO算法，练习2主要实现`_fifo_map_swappable()`和`_fifo_swap_out_victim()`两个函数。这里要维护的可替换物理序列即为双向链表`pra_list_head`，每一个物理页对应的表项为`struct Page`的`pra_page_link`元素。  
对于最简单的FIFO替换算法，在`_fifo_map_swappable()`中只需每次将新换入的物理页插入队尾，而在`_fifo_swap_out_victim()`中只需取出队头，得到其物理页，再从链表中删除这个队头。

我的实现与答案相同。

### extended clock页替换算法
我认为现有的swap_manager框架已经足以支持在ucore中实现此算法。在之后的报告中，将改进的时钟替换算法简称为EC算法。
- 与FIFO算法相同，EC算法也会维护一个按照换入先后顺序排序的双向队列，这一点可由练习2做到。  
- 与FIFO不同的是，每当内存中的物理页帧page被访问或修改时，需要实时地将对应页表项`*ptep`的访问位`P_A`和修改位（脏页标记）`P_D`置1。
- 这样之后，在选择被换出页时（`_ec_swap_out_victim()`函数），就要按照时钟算法的思路，从队头开始循环扫描整个可替换队列，并对标记位作如下变换：
```
    访问位0,修改位0：命中，选择这个页面被换出，将时钟指针指向链表下一项，本次算法结束。
    访问位0,修改为1：将此页面写入交换分区，写入成功后清除D位，并刷新TLB。
    访问位1,修改为0或1：将访问位置0，并刷新TLB。
```
刷新TLB是为了让页面再次被访问或被修改时，AD位能够再次被处理器置位。若不清除，处理器根据TLB的缓存会认为AD位已经被置位，而不修改内存中的值，算法在下次读取时将读到错误的值。这确实会导致性能的损失，但确保了算法和MOOC的讲解一致。

### 2.1 需要被换出的页的特征是什么?
1、被换入的时间较早  
2、最近未被使用（访问）的页更容易被换出  
3、最近未被修改（非脏页）的页更容易被换出

### 2.2 在ucore中如何判断具有这样特征的页?
换入时间可以通过链表来判断，越靠近队头的页，被换入的时间就越早。  
最近是否被访问或修改，可以通过页表项里的PTE_A和PTE_D这两位来判断。

### 2.3 何时进行换入和换出操作?
换入：在出现缺页异常时，若相应的物理页帧不在内存中，则调用`swap_in()`进行换入操作。  
换出：在使用`alloc_pages()`为虚拟地址分配物理内存时，若内存已满，则调用`swap_out()`进行换出操作。
