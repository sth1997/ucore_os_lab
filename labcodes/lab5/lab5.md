# Lab5 实验报告

## 实验涉及知识点  
- 系统调用的原理与实现
- 用户进程的创建
- 加载elf格式的二进制程序
- Copy On Write机制的实现
- 用户进程的生命周期，fork/exec/wait/exit的原理

## 练习1 加载应用程序并执行
练习1的任务是为第一个用户进程设置好`trapframe`，使得在进程切换的中断返回`iret`时，能够从内核态跳到用户态，执行用户应用程序。具体步骤如下：  
- 设置代码段`cs = USER_CS`，数据段`ds, es, ss = USER_DS`。
- 设置`esp = USTACKTOP`，让切换时新的栈顶指针指向用户栈顶。
- 设置`eip = elf_entry`，这使得在执行`iret`后，代码指针跳到用户进程的第一条语句`_start`开始执行。
- 设置`eflags = FL_IF`，让`iret`之后打开中断。

我与答案的实现相同。

### 1.1 请在实验报告中描述当创建一个用户态进程并加载了应用程序后,CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行(RUNNING态)到具体执行应用程序第一条指令的整个经过。  
?????????????????????????????

## 练习2 父进程复制自己的内存空间给子进程
`copy_range()`函数是从`la = start`开始，找到父、子进程中相应的页表项，再得到对应的物理页，一页一页地复制。  
在练习2代码开始之前，已经得到了父、子进程当前对应的物理页，故可直接使用`memcpy()`进行内存拷贝。  
在拷贝之前需要使用`page2kva()`得到两个物理页在各自内存空间对应的虚地址，作为`memcpy()`的参数。  
拷贝之后，还需为子进程的这一页填写对应的页表项，即调用`page_insert()`函数。

我与答案的实现相同

### 2.1 请在实验报告中简要说明如何设计实现”Copy on Write 机制“,给出概要设计,鼓励给出详细设计。
由父进程创建子进程时，在`copy_range()`中，将`share`参数的定义改为“是否采用写时复制”。若采用，则设置父进程的内存空间为**只读**，此时不复制，而是两进程共享父进程的内存空间。  
当父进程或子进程需要修改此空间中的某页面时，由于**只读属性**，就会产生page fault异常，可通过此异常捕捉到“修改者”是哪一进程，则对改进程调用`copy_mm()`复制用户内存空间。这时，我们将不再采用写时复制，因为新复制出来的内存，只有一个进程指向它，新复制出来的内存应设为**可读写**。  
若复制之后，指向原内存空间的进程数等于1，则设置此空间为**可读写**。  

## 练习3 阅读分析源代码,理解进程执行 fork/exec/wait/exit 的实现,以及系统调用的实现  
- do_fork():
创建一个新的进程控制块，此时进程状态为`PROC_UNINIT`。  
之后，将当前进程中除了内核栈和用于存放返回值的eax寄存器以外的所有信息复制到新的进程。  
再将新的进程添加进哈希表，并通过`set_links()`建立新进程与其他进程的关系（添加进链表，与父进程建立联系，等等）。  
最后，唤醒新进程，将其状态置为`PROC_RUNNABLE`，即就绪状态。  

- do_execve()：  
若当前进程的`mm != NULL`，且`mm_count_dec()==0`（说明该mm没有被其他进程共享），则清除当前进程的`mm`。  
调用`load_icode()`来加载elf格式的二进制程序与内存布局到当前进程的内存空间，作为当前进程新的代码。  

- do_wait()：  
不断查看子进程的状态，若待查子进程（或任意一个子进程）处于僵尸态，则释放子进程的进程控制块和内核栈；否则，父进程休眠，休眠原因为`WT_CHILD`，直到被唤醒，再重复此查看过程。

- do_exit()：  
释放当前进程的大部分内存资源（除了进程控制块与内核栈），接着将其所有子进程的父进程置为init进程，然后将当前进程的状态变为ZOMBIE。  
若该进程有父进程，且父进程的状态为SLEEPING，且休眠原因（`wait_state`）为`WT_CHILD`，则可唤醒，并执行`schedule()`让父进程得以运行。  

### 3.1 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的?  
- do_fork()：新建进程控制块（UNINIT），分配内存空间等一些列工作完成后，变为就绪（RUNNABLE）。  
- do_execve()：没有进程状态的改变。  
- do_wait()：检查自己的子进程是否处于“僵尸（ZOMBIE）”状态，有则释放其资源；否则自己转入SLEEPING，休眠原因设为WT_CHILD）。  
- do_exit()：将自己置为ZOMBIE态，若父进程为SLEEPING且休眠原因为WT_CHILD，则唤醒父进程。  

### 3.2 请给出ucore中一个用户态进程的执行状态生命周期图(包执行状态,执行状态之间的变换关系,以及产生变换的事件或函数调用)。(字符方式画即可)  

```
                        RUNNING ------------+---------wait/sleep----------------+
  |                      A    |             |                                   | 
  |                      |    |             |                                   |
 alloc                  proc_run           exit                                 |
  |                      |    |             |                                   |
  V                      |    V             V                                   |
UNINIT ---wakeup -----> RUNNABLE           ZOMBIE --父进程调用了wait--> 完全清空   |
                           A                                                    |
                           |                                                    |
            子进程调用了exit或定时器超时                                           |
                           |                                                    |
                           |                                                    |
                         SLEEPING                                               |
                            A                                                   |
                            |                                                   |
                            |                                                   |
                            +---------------------------------------------------+
```

其中：  
从RUNNABLE--->RUNNING：  proc_run被调用时，作为proc_run的参数  
从RUNNING---->RUNNABLE： proc_run被调用时，作为proc_run的调用者

